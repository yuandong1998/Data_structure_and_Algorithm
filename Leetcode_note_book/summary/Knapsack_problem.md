# 背包问题

[TOC]



背包问题是经典的动态规划问题，

有`n`个物品和容量为`V`的背包，第`i`件物品的体积为`c[i]`，价值为`w[i]`，目标是哪些物体放入背包，以保证在体积不超过背包容量的前提下，背包内的总价值最高。



## 分类

- 01 背包问题
- 完全背包问题
- 多重背包问题
- 混合背包问题
- 二维费用背包问题
- 分组背包问题
- 背包问题求方案数
- 求背包问题的方案
- 有依赖的背包问题



## 01 背包问题

约束条件：每种物品数量为 1，可以选择放或不放。

状态定义：`f[i][v]` 为前 `i` 个物品中，体积恰好为 `v` 时的最大价值。

状态转移方程：`f[i][v] = max(f[i-1][v], f[i-1][v-c[i]] + w[i])`

代码实现，`f[i][v]`为二维数组：

```C++
for i = 1, 2, ..., n: # 枚举前 i 个物品
    for v = 0, 1, ..., V: # 枚举体积
        f[i][v] = f[i-1][v]; # 不选第 i 个物品
        if v >= c[i]:  # 第 i 个物品的体积必须小于 v 才能选
            f[i][v] = max(f[i][v], f[i-1][v-c[i]] + w[i])
return max(f[n][0...V]) # 返回前 n 个物品的最大值
```

优化，用一维数组来实现，优化空间复杂度为$O(V)$。

```C++
for i = 1, 2, ..., n: # 枚举前 i 个物品
    for v = V, V-1, ..., c[i]: # 注意这里是倒序遍历，
            f[v] = max(f[v], f[v-c[i]] + w[i])
return f[V] # 返回前 n 个物品时的最大值，为体积小于等于 V 时的最大价值
```



## 完全背包问题

约束条件：每种物品的数量为无限个，你可以选择任意数量的物品。

状态定义：`f[i][v]` 为前 `i` 种物品中，体积恰好为 `v` 时的最大价值。

状态转移方程：`f[i][v] = max(f[i-1][v-k*c[i]] + k*w[i]), 0 <=k*c[i]<=v`

由于`f[i][v-c[i]]=max(f[i-1][v-k*c[i]]+k*w[i]),1<=k<=v`，这里可以自底向上的计算。

代码实现与优化：

```C++
for i = 1, 2, ..., n: # 枚举前 i 个物品
    for v = 0, 1, ..., V: # 注意这里是正序遍历，
            f[v] = max(f[v], f[v-c[i]] + w[i])
return f[V] # 返回前 n 个物品时的最大值，为体积小于等于 V 时的最大价值
```



## Reference

[1] [背包，个人意见，大家分享](https://leetcode-cn.com/problems/coin-lcci/solution/bei-bao-jiu-jiang-ge-ren-yi-jian-da-jia-fen-xiang-/)